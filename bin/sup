#!/usr/bin/env ruby

require 'rubygems'
require 'ncurses'
require 'trollop'
require "sup"

$opts = Trollop::options do
  version "sup v#{Redwood::VERSION}"
  banner <<EOS
Sup is a curses-based email client.

Usage:
  sup [options]

Options are:
EOS
  opt :no_threads, "Turn of threading. Helps with debugging. (Necessarily disables background polling for new messages.)"
end

Thread.abort_on_exception = true # make debugging possible

module Redwood

global_keymap = Keymap.new do |k|
  k.add :quit, "Quit Redwood", 'q'
  k.add :help, "Show help", 'H', '?'
  k.add :roll_buffers, "Switch to next buffer", 'b'
#  k.add :roll_buffers_backwards, "Switch to previous buffer", 'B'
  k.add :kill_buffer, "Kill the current buffer", 'x'
  k.add :list_buffers, "List all buffers", 'B'
  k.add :list_contacts, "List contacts", 'C'
  k.add :redraw, "Redraw screen", :ctrl_l
  k.add :search, "Search messages", '/'
  k.add :list_labels, "List labels", 'L'
  k.add :poll, "Poll for new messages", 'P'
  k.add :compose, "Compose new message", 'm'
  k.add :recall_draft, "Edit most recent draft message", 'R'
end

def start_cursing
  Ncurses.initscr
  Ncurses.noecho
  Ncurses.cbreak
  Ncurses.stdscr.keypad 1
  Ncurses.curs_set 0
  Ncurses.start_color
end

def stop_cursing
  Ncurses.curs_set 1
  Ncurses.echo
  Ncurses.endwin
end
module_function :start_cursing, :stop_cursing

Redwood::start
Index.new.load

if(s = Index.source_for DraftManager.source_name)
  DraftManager.source = s
else
  Index.add_source DraftManager.new_source
end

if(s = Index.source_for SentManager.source_name)
  SentManager.source = s
else
  Index.add_source SentManager.new_source
end

begin
  log "starting curses"
  start_cursing

  log "initializing colormap"
  Colormap.new do |c|
    c.add :status_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLUE, Ncurses::A_BOLD
    c.add :index_old_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK
    c.add :index_new_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK, 
           Ncurses::A_BOLD
    c.add :index_starred_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK, 
           Ncurses::A_BOLD
    c.add :labellist_old_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK
    c.add :labellist_new_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK, 
           Ncurses::A_BOLD
    c.add :twiddle_color, Ncurses::COLOR_BLUE, Ncurses::COLOR_BLACK
    c.add :label_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :message_patina_color, Ncurses::COLOR_BLACK, Ncurses::COLOR_GREEN
    c.add :alternate_patina_color, Ncurses::COLOR_BLACK, Ncurses::COLOR_BLUE
    c.add :missing_message_color, Ncurses::COLOR_BLACK, Ncurses::COLOR_RED
    c.add :mime_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
    c.add :quote_patina_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :sig_patina_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :quote_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :sig_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :to_me_color, Ncurses::COLOR_GREEN, Ncurses::COLOR_BLACK
    c.add :starred_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK,
          Ncurses::A_BOLD
    c.add :starred_patina_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_GREEN,
          Ncurses::A_BOLD
    c.add :alternate_starred_patina_color, Ncurses::COLOR_YELLOW,
          Ncurses::COLOR_BLUE, Ncurses::A_BOLD
    c.add :snippet_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
    c.add :option_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK
    c.add :tagged_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK,
          Ncurses::A_BOLD
    c.add :draft_notification_color, Ncurses::COLOR_RED, Ncurses::COLOR_BLACK,
          Ncurses::A_BOLD
  end

  log "initializing buffer manager"
  bm = BufferManager.new

  log "initializing mail index buffer"
  imode = InboxMode.new
  ibuf = bm.spawn "Inbox", imode

  log "ready for interaction!"
  Logger.make_buf

  bm.draw_screen

  begin
    Index.usual_sources.each { |s| s.check }
  rescue SourceError
    # do nothing! we'll report it at the next step
  end
  Redwood::report_broken_sources
  
  Index.usual_sources.each do |s|
    reporting_thread do
      begin
        s.connect
      rescue SourceError => e
        Redwood::log "fatal error loading from #{s}: #{e.message}"
      end
    end if s.respond_to? :connect
  end

  imode.load_threads :num => ibuf.content_height, :when_done => lambda { reporting_thread { sleep 1; PollManager.poll } }

  PollManager.start_thread unless $opts[:no_threads]

  until $exception
    bm.draw_screen
    c = Ncurses.nonblocking_getch
    bm.erase_flash

    if c == Ncurses::KEY_RESIZE
      bm.handle_resize
    elsif c
      unless bm.handle_input(c)
        x = global_keymap.action_for c
        case x
        when :quit
          break if bm.kill_all_buffers_safely
        when :help
          curmode = bm.focus_buf.mode
          bm.spawn_unless_exists("<help for #{curmode.name}>") { HelpMode.new curmode, global_keymap }
        when :roll_buffers
          bm.roll_buffers
        when :roll_buffers_backwards
          bm.roll_buffers_backwards
        when :kill_buffer
          bm.kill_buffer_safely bm.focus_buf
        when :list_buffers
          bm.spawn_unless_exists("Buffer List") { BufferListMode.new }
        when :list_contacts
          b = bm.spawn_unless_exists("Contact List") { ContactListMode.new }
          b.mode.load_in_background
        when :search
          text = bm.ask :search, "query: "
          next unless text && text !~ /^\s*$/

          begin
            qobj = Index.parse_user_query_string text
            short_text = text.length < 20 ? text : text[0 ... 20] + "..."
            log "built query from #{text.inspect}: #{qobj}"
            mode = SearchResultsMode.new qobj
            bm.spawn "search: \"#{short_text}\"", mode
            mode.load_threads :num => mode.buffer.content_height
          rescue Ferret::QueryParser::QueryParseException => e
            bm.flash "Couldn't parse query."
          end
        when :list_labels
          b = bm.spawn_unless_exists("Label list") { LabelListMode.new }
          b.mode.load_in_background
        when :compose
          mode = ComposeMode.new
          bm.spawn "New Message", mode
          mode.edit
        when :poll
#          bm.raise_to_front PollManager.buffer
          reporting_thread { PollManager.poll }
        when :recall_draft
          case Index.num_results_for :label => :draft
          when 0
            bm.flash "No draft messages."
          when 1
            m = nil
            Index.each_id_by_date(:label => :draft) { |mid, builder| m = builder.call }
            r = ResumeMode.new(m)
            BufferManager.spawn "Edit message", r
            r.edit
          else
            b = BufferManager.spawn_unless_exists("All drafts") do
              mode = LabelSearchResultsMode.new [:draft]
            end
            b.mode.load_threads :num => b.content_height
          end
        when :nothing
        when :redraw
          bm.completely_redraw_screen
        else
          bm.flash "Unknown key press '#{c.to_character}' for #{bm.focus_buf.mode.name}."
        end
      end
    end
  end
rescue Exception => e
  $exception ||= e
ensure
  Redwood::finish
  stop_cursing
  if $exception
    Redwood::log "oh crap, an exception"
  else
    Redwood::log "good night, sweet prince!"
  end
end

Index.save unless $exception # TODO: think about this

if $exception 
  $stderr.puts <<EOS
----------------------------------------------------------------
I'm very sorry, but it seems that an error occurred in Sup. 
Please accept my sincere apologies. If you don't mind, please
send the backtrace below and a brief report of the circumstances
to wmorgan-sup at masanjin dot nets so that I might address this
problem. Thank you!

Sincerely,
William
----------------------------------------------------------------

The problem was: #{$exception.message} (error type #{$exception.class.name})
A backtrace follows:
EOS
  raise $exception
end

end
