#!/usr/bin/env ruby

require 'rubygems'
require 'ncurses'
require 'curses'
require 'fileutils'
require 'trollop'
require "sup"

$opts = Trollop::options do
  version "sup v#{Redwood::VERSION}"
  banner <<EOS
Sup is a curses-based email client.

Usage:
  sup [options]

Options are:
EOS
  opt :list_hooks, "List all hooks and descriptions thereof, and quit."
  opt :no_threads, "Turn of threading. Helps with debugging. (Necessarily disables background polling for new messages.)"
end

if $opts[:list_hooks]
  Redwood::HookManager.print_hooks
  exit
end

Thread.abort_on_exception = true # make debugging possible

module Redwood

global_keymap = Keymap.new do |k|
  k.add :quit, "Quit Redwood", 'q'
  k.add :help, "Show help", 'H', '?'
  k.add :roll_buffers, "Switch to next buffer", 'b'
#  k.add :roll_buffers_backwards, "Switch to previous buffer", 'B'
  k.add :kill_buffer, "Kill the current buffer", 'x'
  k.add :list_buffers, "List all buffers", 'B'
  k.add :list_contacts, "List contacts", 'C'
  k.add :redraw, "Redraw screen", :ctrl_l
  k.add :search, "Search messages", '/'
  k.add :list_labels, "List labels", 'L'
  k.add :poll, "Poll for new messages", 'P'
  k.add :compose, "Compose new message", 'm'
  k.add :recall_draft, "Edit most recent draft message", 'R'
end

def start_cursing
  Ncurses.initscr
  Ncurses.noecho
  Ncurses.cbreak
  Ncurses.stdscr.keypad 1
  Ncurses.curs_set 0
  Ncurses.start_color
  $cursing = true
end

def stop_cursing
  return unless $cursing
  Ncurses.curs_set 1
  Ncurses.echo
  Ncurses.endwin
end
module_function :start_cursing, :stop_cursing

Index.new
begin
  Index.lock
rescue Index::LockError => e
  require 'highline'

  h = HighLine.new
  h.wrap_at = :auto
  h.say Index.fancy_lock_error_message_for(e)

  case h.ask("Should I ask that process to kill itself? ")
  when /^\s*y\s*$/i
    h.say "Ok, suggesting sepuku..."
    FileUtils.touch Redwood::SUICIDE_FN
    sleep SuicideManager::DELAY * 2
    FileUtils.rm_f Redwood::SUICIDE_FN
    h.say "Let's try that again."
    retry
  else
    h.say <<EOS
Ok, giving up. If the process crashed and left a stale lockfile, you
can fix this by manually deleting #{Index.lockfile}.
EOS
    exit
  end
end

begin
  extend CanSpawnComposeMode
  Redwood::start
  Index.load

  if(s = Index.source_for DraftManager.source_name)
    DraftManager.source = s
  else
    Index.add_source DraftManager.new_source
  end

  if(s = Index.source_for SentManager.source_name)
    SentManager.source = s
  else
    Index.add_source SentManager.new_source
  end

  log "starting curses"
  start_cursing

  log "initializing colormap"
  Colormap.new do |c|
    c.add :status_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLUE, Ncurses::A_BOLD
    c.add :index_old_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK
    c.add :index_new_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK, 
           Ncurses::A_BOLD
    c.add :index_starred_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK, 
           Ncurses::A_BOLD
    c.add :labellist_old_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK
    c.add :labellist_new_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK, 
           Ncurses::A_BOLD
    c.add :twiddle_color, Ncurses::COLOR_BLUE, Ncurses::COLOR_BLACK
    c.add :label_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :message_patina_color, Ncurses::COLOR_BLACK, Ncurses::COLOR_GREEN
    c.add :alternate_patina_color, Ncurses::COLOR_BLACK, Ncurses::COLOR_BLUE
    c.add :missing_message_color, Ncurses::COLOR_BLACK, Ncurses::COLOR_RED
    c.add :attachment_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
    c.add :cryptosig_valid_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK, Ncurses::A_BOLD
    c.add :cryptosig_unknown_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
    c.add :cryptosig_invalid_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_RED, Ncurses::A_BOLD
    c.add :generic_notice_patina_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
    c.add :quote_patina_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :sig_patina_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :quote_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :sig_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK
    c.add :to_me_color, Ncurses::COLOR_GREEN, Ncurses::COLOR_BLACK
    c.add :starred_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK,
          Ncurses::A_BOLD
    c.add :starred_patina_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_GREEN,
          Ncurses::A_BOLD
    c.add :alternate_starred_patina_color, Ncurses::COLOR_YELLOW,
          Ncurses::COLOR_BLUE, Ncurses::A_BOLD
    c.add :snippet_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
    c.add :option_color, Ncurses::COLOR_WHITE, Ncurses::COLOR_BLACK
    c.add :tagged_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK,
          Ncurses::A_BOLD
    c.add :draft_notification_color, Ncurses::COLOR_RED, Ncurses::COLOR_BLACK,
          Ncurses::A_BOLD
    c.add :completion_character_color, Ncurses::COLOR_WHITE,
          Ncurses::COLOR_BLACK, Ncurses::A_BOLD
    c.add :reply_mode_selected_color, Ncurses::COLOR_YELLOW, Ncurses::COLOR_BLACK, Ncurses::A_BOLD
    c.add :reply_mode_unselected_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
    c.add :reply_mode_label_color, Ncurses::COLOR_CYAN, Ncurses::COLOR_BLACK
  end

  log "initializing buffer manager"
  bm = BufferManager.new

  log "initializing mail index buffer"
  imode = InboxMode.new
  ibuf = bm.spawn "Inbox", imode

  log "ready for interaction!"
  Logger.make_buf

  bm.draw_screen

  begin
    Index.usual_sources.each { |s| s.check }
  rescue SourceError
    # do nothing! we'll report it at the next step
  end
  Redwood::report_broken_sources
  
  Index.usual_sources.each do |s|
    reporting_thread do
      begin
        s.connect
      rescue SourceError => e
        Redwood::log "fatal error loading from #{s}: #{e.message}"
      end
    end if s.respond_to? :connect
  end

  imode.load_threads :num => ibuf.content_height, :when_done => lambda { reporting_thread { sleep 1; PollManager.poll } unless $opts[:no_threads] }

  unless $opts[:no_threads]
    PollManager.start
    SuicideManager.start
    Index.start_lock_update_thread
  end

  until $exception || SuicideManager.die?
    c = Ncurses.nonblocking_getch
    next unless c
    bm.erase_flash

    unless bm.handle_input(c)
      x = global_keymap.action_for c
      case x
      when :quit
        break if bm.kill_all_buffers_safely
      when :help
        curmode = bm.focus_buf.mode
        bm.spawn_unless_exists("<help for #{curmode.name}>") { HelpMode.new curmode, global_keymap }
      when :roll_buffers
        bm.roll_buffers
      when :roll_buffers_backwards
        bm.roll_buffers_backwards
      when :kill_buffer
        bm.kill_buffer_safely bm.focus_buf
      when :list_buffers
        bm.spawn_unless_exists("Buffer List") { BufferListMode.new }
      when :list_contacts
        b = bm.spawn_unless_exists("Contact List") { ContactListMode.new }
        b.mode.load_in_background
      when :search
        SearchResultsMode.spawn_by_query
      when :list_labels
        labels = LabelManager.listable_labels.map { |l| LabelManager.string_for l }
        user_label = bm.ask_with_completions :label, "Show threads with label (enter for listing): ", labels
        user_label =
          case user_label
          when nil, /^\s*$/
            bm.spawn_modal("Label list", LabelListMode.new) if user_label && user_label.empty?
          else
            LabelManager.label_for user_label
          end
        
        case user_label
        when nil
        when :inbox
          BufferManager.raise_to_front InboxMode.instance.buffer
        else
          b = BufferManager.spawn_unless_exists("All threads with label '#{user_label}'") do
            mode = LabelSearchResultsMode.new([user_label])
          end
          b.mode.load_threads :num => b.content_height
        end

      when :compose
        spawn_compose_mode
      when :poll
        reporting_thread { PollManager.poll }
      when :recall_draft
        case Index.num_results_for :label => :draft
        when 0
          bm.flash "No draft messages."
        when 1
          m = nil
          Index.each_id_by_date(:label => :draft) { |mid, builder| m = builder.call }
          r = ResumeMode.new(m)
          BufferManager.spawn "Edit message", r
          r.edit_message
        else
          b = BufferManager.spawn_unless_exists("All drafts") do
            mode = LabelSearchResultsMode.new [:draft]
          end
          b.mode.load_threads :num => b.content_height
        end
      when :nothing
      when :redraw
        bm.completely_redraw_screen
      else
        bm.flash "Unknown key press '#{c.to_character}' for #{bm.focus_buf.mode.name}."
      end
    end

    bm.draw_screen
  end
rescue Exception => e
  $exception ||= e
ensure
  unless $opts[:no_threads]
    PollManager.stop if PollManager.instantiated?
    SuicideManager.stop if PollManager.instantiated?
    Index.stop_lock_update_thread
  end

  Redwood::finish
  stop_cursing
  Redwood::log "stopped cursing"

  if SuicideManager.instantiated? && SuicideManager.die?
    Redwood::log "I've been ordered to commit sepuku. I obey!"
  end

  case $exception
  when nil
    Redwood::log "no fatal errors. good job, william."
    Index.save
  else
    Redwood::log "oh crap, an exception"
  end

  Index.unlock
end

if $exception 
  $stderr.puts <<EOS
----------------------------------------------------------------
I'm very sorry, but it seems that an error occurred in Sup. 
Please accept my sincere apologies. If you don't mind, please
send the backtrace below and a brief report of the circumstances
to sup-talk at rubyforge dot orgs so that I might address this
problem. Thank you!

Sincerely,
William
----------------------------------------------------------------

The problem was: '#{$exception.message}' (error type #{$exception.class.name})
A backtrace follows:
EOS
  raise $exception
end

end
